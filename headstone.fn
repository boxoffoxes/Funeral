-- vim:filetype=funeral
-- def head [ dip 'drop uncons ]
-- def tail [ drop uncons ]
-- 
-- def test [ dip [ ifte "ok" "failed" = apply ] ]
-- 
-- def concat [ fold [append swap] [] ]
-- 
-- 
-- 
-- TEST [ cons dip 'cons partition [ = 0 % 2 ] [1 2 3 4] [] ]
	 -- [ [2 4] [1 3] ]  "partition"

-- def partition [ -- 'f [list]
	-- doif
		-- [ drop dig 3 'drop ]
		-- [
			-- doif
				-- [ dip   [cons exhume 2] ] -- 'f [t] [] [sil]
				-- [ dig 2 [cons swap]     ] -- 'f [] [t] [sil]
			-- swap *apply         		  -- b 'f [] [] t [sil]
			-- dip   [exhume 2]    		  -- 'f t [] [] t [sil]
			-- dig 3 [dup uncons]  		  -- 'f [] [] t t [sil]
		-- ]
	-- exhume 3 dig 3 '*null 				  -- False 'f [] [] [tsil]
	-- dip [ [] [] reverse ] 				  -- 'f [] [] [tsil]
-- ]

-- case [ 1 'f1  2 'f2  3 'f3 ... 'else ]
--def case []

def *isString [ isString dup ]
def concat [ fold 'append [] ]

def prepend [ append swap ]

def *partition [ partition dip 'dup ]
def partition [ -- 'pred [list]
	filter 
    dig 2 [filter append swap 'not]
    unrot dup2
]

def *filter [ filter dip 'dup ]
def filter [ -- 'pred [list]
    reverse drop drop
    times swap [ 
        doif
            [ dig 2 'cons unrot ]
            'drop
        rot uncons dip 'uncons 
    ] *length
    unrot [] swap *map
]

def *length [length dup]
def length [
    fold [+ 1 drop] 0
]

def file [ -- 'pred [dest1] [dest2] elem
	doif
		[ dip exhume 2 ] -- file in dest1
		[] -- file in dest2
	rot dig 2 'apply unrot
	dig 3 'dup
]

def *map [ map dip 'dup ]
def map [ -- 'f [list]
    fold
	-- append 'swap
	append exhume 2  -- recover 'f
	'cons
	[]
	dip 'reverse
]

def foldr* [ fold dig 2 [reverse dup] ]
def foldr [ fold dig 2 'reverse ]

def reverse [ fold 'cons [] ]

def odd [= 1 % 2]
def even [= 0 % 2]

-- fold [fun] start [list]
def *fold [ fold dig 2 'dup ]
def fold [ -- 'f start [list] // repeats f .l start
	doif
		[ dip 'drop drop ]
		[ fold *apply dip 'swap dig 2 'uncons ]
	dip 'unrot *null rot
]

def dup2 [ dup dip 'dup ]
def rot  [ exhume 2 ]
def unrot [ bury 2 ]
def *null [ null dup ]

-- def while [ -- 'pred 'f // execute 'f while 'pred remains true
-- 	doif
-- 		[dip 'while exhume 2 dip '*apply]
-- 		[drop drop]
-- 	bury 2 dip [ swap *apply dip 'dup ] swap
-- ]

def for [ -- n 'fun // execute 'fun on the top n stack items
	doif
		[ dip [for - 1] exhume 2 dip '*apply ]
		[ drop drop ]
	> 0 dup
]

-- n [fun] // Repeat [fun] n times.
def times [
    doif 
		[ times - 1 dip '*apply ]
		[ drop drop ]
	> 0 dup
]
def *apply [ dip 'apply dup ]

def doif [ apply ifte ]
def ifte [ or dip 'and swap ]
def swap [ exhume 1 ]
def *head [ head dup ]
def head [ dip 'drop uncons ]
def *uncons [ uncons dup ]
