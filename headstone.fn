-- vim:filetype=funeral
-- def head [ dip 'drop uncons ]
-- def tail [ drop uncons ]
-- 
-- def test [ dip [ ifte "ok" "failed" = apply ] ]
-- 
-- def concat [ fold [append swap] [] ]
-- 
-- 
-- 
-- TEST [ cons dip 'cons partition [ = 0 % 2 ] [1 2 3 4] [] ]
	 -- [ [2 4] [1 3] ]  "partition"

-- def partition [ -- 'f [list]
	-- doif
		-- [ drop dig 3 'drop ]
		-- [
			-- doif
				-- [ dip   [cons exhume 2] ] -- 'f [t] [] [sil]
				-- [ dig 2 [cons swap]     ] -- 'f [] [t] [sil]
			-- swap *apply         		  -- b 'f [] [] t [sil]
			-- dip   [exhume 2]    		  -- 'f t [] [] t [sil]
			-- dig 3 [dup uncons]  		  -- 'f [] [] t t [sil]
		-- ]
	-- exhume 3 dig 3 '*null 				  -- False 'f [] [] [tsil]
	-- dip [ [] [] reverse ] 				  -- 'f [] [] [tsil]
-- ]

-- case [ 1 'f1  2 'f2  3 'f3 ... 'else ]
--def case []

def concat [ fold 'prepend [] ]

def prepend [ append swap ]

def *partition [ partition dip 'dup ]
def partition [ -- 'pred [list]
	filter 
    dig 2 [filter append swap 'not]
    unrot dup2
]

def *filter [ filter dip 'dup ]
def filter [ -- 'pred [list]
    reverse drop drop
    times swap [ 
        doif
            [ dig 2 'cons unrot ]
            'drop
        rot uncons dip 'uncons 
    ] *length
    unrot [] swap *map
]

def *length [length dup]
def length [
    fold [+ 1 dip 'drop] 0
]

def file [ -- 'pred [dest1] [dest2] elem
	doif
		[ dip exhume 2 ] -- file in dest1
		[] -- file in dest2
	rot dig 2 'apply unrot
	dig 3 'dup
]

def *map [ map dip 'dup ]
def map [ -- 'f [list]
    fold  -- result: fold [ cons f swap ] []
	append 'swap
	append exhume 2  -- recover 'f
	'cons
	[]
	dip 'reverse
]

def reverse [ fold [cons swap] [] ]

def odd [= 1 % 2]
def even [= 0 % 2]

-- fold [fun] start [list]
def *fold [ fold dig 2 'dup ]
def fold [
    doif
        [ dip 'drop drop ] -- cleanup
        [ fold *apply dig 2 'uncons ]
    dip 'unrot *null rot
]

def dup2 [ dup dip 'dup ]
def rot  [ exhume 2 ]
def unrot [ bury 2 ]
def *null [ null dup ]


-- n [fun] // Do [fun] n times.
def times [
    doif [ times - 1 dip '*apply ] [ drop drop ] > 0 dup
]
def *apply [ dip 'apply dup ]

def doif [ apply ifte ]
def ifte [ or dip 'and swap ]
def swap [ exhume 1 ]
